import {Injectable} from '@angular/core';
import {FacebookPostModel} from '../models/facebook-post.model';
import {AmplifyAppSyncService} from 'src/app/shared/services/amplify-app-sync.service';
import {AutoRecommendationModel} from '../models/auto-recommendation.model';
import {PostRecommendationModel} from '../models/post-recommendation.model';
import {GroupModel} from 'src/app/shared/models/group.model';
import {TimePeriod} from '../../shared/enums/time-period.enum';
import {BehaviorSubject} from 'rxjs';
import {LoggerService} from '@sharedModule/services/logger.service';
import {DateTime} from '@sharedModule/models/date-time';

@Injectable()
export class PublishService {
	public recommendation: PostRecommendationModel;
	public nextBestTimeRecommendation: PostRecommendationModel;
	public postToBeEdited: FacebookPostModel;
	public actionTaken: string;
	public selectedPostRecommendationDate: any;
	public numOfGroupSelected;
	public _selectedGroups;
	public postToBeReShared;
	public selectedGroup = new BehaviorSubject<GroupModel>(null);

	constructor(private readonly amplifyClient: AmplifyAppSyncService, private readonly logger: LoggerService) {}

	private _dateTimeSelectedFromRecommendation;
	public _selectedPostOption;

	setSelectedGroup(group) {
		this.selectedGroup.next(group);
	}

	get selectedGroups() {
		return this._selectedGroups;
	}

	set selectedGroups(selectedGroups) {
		this._selectedGroups = selectedGroups;
	}

	get timeSelectedFromRecommendation(): string {
		return this._dateTimeSelectedFromRecommendation.format('h:mm A');
	}

	get dateSelectedFromRecommendation(): Date {
		return this._dateTimeSelectedFromRecommendation ? this._dateTimeSelectedFromRecommendation.toDate() : null;
	}

	set dateTimeSelectedFromRecommendation(date: DateTime) {
		this._dateTimeSelectedFromRecommendation = date;
	}

	set selectedPostOption(postOption) {
		this._selectedPostOption = postOption;
	}

	get selectedPostOption() {
		return this._selectedPostOption;
	}

	async createPost(newPost: FacebookPostModel) {
		newPost.makeItReadyForSendingToBackend();
		delete newPost.id;
		await this.amplifyClient.CreateFbPostModel(newPost);
	}

	async editPost(newPost: FacebookPostModel) {
		newPost.makeItReadyForSendingToBackend('edit');
		await this.amplifyClient.updateFbModel(newPost);
	}

	async markScheduledPostDeleted(existingPost: FacebookPostModel) {
		const postToBeDeleted = {
			groupId: existingPost.groupId,
			toBePostedAtUTCTicks: existingPost.toBePostedAtUTCTicks,
			isDeleted: existingPost.isDeleted
		};

		await this.amplifyClient.updateFbModel(postToBeDeleted);
	}

	async createPosts(newPosts: FacebookPostModel[]) {
		const calls = [];
		newPosts.forEach(post => calls.push(this.createPost(post)));
		await Promise.all(calls);
	}

	async editPosts(newPosts: FacebookPostModel[]) {
		const calls = [];
		newPosts.forEach(post => calls.push(this.editPost(post)));
		await Promise.all(calls);
	}

	async getScheduledFbPosts(groupId: string): Promise<FacebookPostModel[]> {
		const startDate = new DateTime().utc().unix();
		return (await this.getFbPosts(groupId, startDate)).filter(
			result => result.isDeleted !== true
		) as any as FacebookPostModel[];
	}

	async getAutoGeneratedRecommendation(groupId: string): Promise<AutoRecommendationModel> {
		const result = await this.amplifyClient.GetGRecommendationByDay(groupId);
		return result as any as AutoRecommendationModel;
	}

	async getRecommendation(groupId: string): Promise<PostRecommendationModel> {
		const result = await this.amplifyClient.GetGRecommendationByDay(groupId);
		return result as any as PostRecommendationModel;
	}

	async getPostsCreated(groupId: string, timePeriod: TimePeriod): Promise<FacebookPostModel[]> {
		const endDate = new DateTime()
			.utc()
			.subtract(timePeriod.value.endDateOffSet, timePeriod.value.offSetType)
			.endOf(timePeriod.value.offSetType)
			.unix();
		const startDate = new DateTime()
			.utc()
			.subtract(timePeriod.value.startDateOffSet, timePeriod.value.offSetType)
			.startOf(timePeriod.value.offSetType)
			.unix();

		const response = (await this.getFbPosts(groupId, startDate, endDate)).filter(post => post.status === 'Published');
		const fbAnalyticsResponse = await this.getFbPostAnalytics(
			response.map(x => x.fbPostId.replace('/', '')) as string[],
			groupId
		);

		response.forEach((res, i) => (res['analytics'] = fbAnalyticsResponse[i] ? fbAnalyticsResponse[i] : []));

		return response;
	}

	async getFbPosts(
		groupId: string,
		startDate: number,
		endDate: number = null,
		nextToken: string = null,
		prevResponse: any[] = null
	): Promise<any[]> {
		if (!nextToken && prevResponse) {
			return prevResponse;
		}

		const fbPosts = await this.amplifyClient.listFbPostModels(groupId, startDate, endDate, null, nextToken);
		fbPosts.items = prevResponse !== null ? prevResponse.concat(fbPosts.items) : fbPosts.items;

		return await this.getFbPosts(groupId, startDate, endDate, fbPosts.nextToken, fbPosts.items);
	}

	async getFbPostAnalytics(fbPostIds: string[], groupId: string) {
		const fbAnalyticsRequests = [];
		while (fbPostIds.length) {
			const ids = fbPostIds.splice(0, 100);
			fbAnalyticsRequests.push(this.amplifyClient.listPostAnalytics(ids, groupId));
		}

		return ((await Promise.all(fbAnalyticsRequests)) as any).flatMap(x => x);
	}

	async getTopPostsAllTypeByGroupId(groupId, limit, startMonth, endMonth, startYear, endYear) {
		return await this.amplifyClient.getTopPostsAllTypeByGroupId(
			groupId,
			limit,
			startMonth,
			endMonth,
			startYear,
			endYear
		);
	}

	async getZeroCommentPostsByGroupId(groupId, postType, startMonth, startYear, endMonth, endYear, limit) {
		return await this.amplifyClient.getZeroCommentPostsByGroupId(
			groupId,
			postType,
			startMonth,
			startYear,
			endMonth,
			endYear,
			limit
		);
	}

	markUnansweredPostAsRead(id, groupId) {
		return this.amplifyClient.markUnansweredPostAsRead(id, groupId);
	}

	async getSuggestionMet(suggestionReq, groupId) {
		try {
			return JSON.parse(await this.amplifyClient.getSuggestionMet(JSON.stringify(suggestionReq)));
		} catch (e) {
			this.logger.debug(
				'Error while calculating suggestion met',
				{groupId: groupId},
				'PostComposerComponent',
				'checkSuggestion'
			);
			return {};
		}
	}

	resetData() {
		this.recommendation = null;
		this.nextBestTimeRecommendation = null;
		this.postToBeEdited = null;
	}

	getCalenderDates() {
		const dates = [];
		let date = null;
		for (let index = 0; index <= 30; index++) {
			date = new DateTime().add(index, 'd');
			dates.push([date.format('MMM'), date.date(), date.year(), date, date.format('MMMM')]);
		}

		return dates;
	}

	getTimesOnWhichPostCanBePublished(): string[] {
		const timeOptions = [];
		let ampmSuffix = 'AM';
		timeOptions.push('12:00 AM');
		timeOptions.push('12:15 AM');
		timeOptions.push('12:30 AM');
		timeOptions.push('12:45 AM');

		for (let i = 0; i < 2; i++) {
			for (let j = 1; j < 12; j++) {
				timeOptions.push(j + ':00 ' + ampmSuffix);
				timeOptions.push(j + ':15 ' + ampmSuffix);
				timeOptions.push(j + ':30 ' + ampmSuffix);
				timeOptions.push(j + ':45 ' + ampmSuffix);
			}

			if (i === 1) {
				break;
			}

			ampmSuffix = 'PM';
			timeOptions.push('12:00 PM');
			timeOptions.push('12:15 PM');
			timeOptions.push('12:30 PM');
			timeOptions.push('12:45 PM');
		}

		return timeOptions;
	}

	getPostAnalyticsDateForUI(dateTick) {
		return new DateTime().parseUnix(dateTick).format('DD MMM YY [at] h[:]mm a');
	}

	async getPostFromPostId(groupId, postId) {
		try {
			return (await this.amplifyClient.fetchConversationBySourceIds(groupId, [postId]))[0];
		} catch (e) {
			throw e;
		}
	}
}
