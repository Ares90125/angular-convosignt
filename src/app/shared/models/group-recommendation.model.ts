import {AutoRecommendationModel} from 'src/app/group-admin/models/auto-recommendation.model';
import {PostContentTypeEnum} from 'src/app/group-admin/models/facebook-post.model';
import {PostRecommendationModel, RecommendationType} from 'src/app/group-admin/models/post-recommendation.model';
import {PublishService} from 'src/app/group-admin/_services/publish.service';
import {environment} from '../../../environments/environment';
import {DateTime} from '@sharedModule/models/date-time';

export class GroupRecommendationModel {
	calenderDates = [];
	recommendations = {};
	recommendationIdHashMap = {};

	public constructor(private readonly _groupId, private readonly _publishService: PublishService) {}

	async getNextRecommendedSchedule() {
		let nextBestRecommendation;
		const keys = Object.keys(this.recommendations);
		for (let i = 0; i < keys.length; i++) {
			this.recommendations[keys[i]].forEach(recommendation => {
				if (!nextBestRecommendation) {
					nextBestRecommendation = recommendation;
				} else if (
					new DateTime()
						.parseUnix(nextBestRecommendation.toBePostedAtUTCTicks)
						.isAfter(new DateTime().parseUnix(recommendation.toBePostedAtUTCTicks).dayJsObj)
				) {
					nextBestRecommendation = recommendation;
				}
			});
		}

		return nextBestRecommendation ? nextBestRecommendation : null;
	}

	async loadRecommendations() {
		this.calenderDates = this._publishService.getCalenderDates();
		await this.loadAutoRecommendations();
	}

	async loadAutoRecommendations() {
		const recommendation = await this._publishService.getAutoGeneratedRecommendation(this._groupId);
		if (recommendation !== null) {
			await this.generateRecommendationsFromAuto(recommendation);
		}
	}

	generateRecommendationsFromAuto(autoRecommendation: AutoRecommendationModel) {
		const recommendationsMap = {};
		const daysOfTheWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

		let timings = {};
		try {
			timings = JSON.parse(autoRecommendation.timings);
		} catch (error) {}

		let contentTypes = {};
		try {
			contentTypes = JSON.parse(autoRecommendation.contentTypes);
		} catch (error) {}

		let optLength = null;
		try {
			optLength = JSON.parse(autoRecommendation.optLength);
			optLength = optLength.minChar || optLength.minWord ? optLength : null;
		} catch (error) {}
		const keywords = autoRecommendation.keywords ? autoRecommendation.keywords.split('|') : null;
		const topics = autoRecommendation.topics ? autoRecommendation.topics.split('|') : null;
		const categories = autoRecommendation.categories ? autoRecommendation.categories.split('|') : null;
		const emotions = autoRecommendation.emotions || null;
		daysOfTheWeek.forEach(day => {
			recommendationsMap[day] = [];
			if (timings && timings[day]) {
				timings[day].forEach(timing => {
					const newRecomendation = new PostRecommendationModel();
					newRecomendation.type = RecommendationType.Timing;
					newRecomendation.optLength = optLength;
					newRecomendation.keywords = keywords;
					newRecomendation.topics = topics;
					newRecomendation.categories = categories;
					newRecomendation.emotions = emotions;
					newRecomendation.toBePostedAtUTCHour = timing;
					recommendationsMap[day].push(newRecomendation);
				});
			}
			const lowerCaseDay = day.toLocaleLowerCase();
			if (contentTypes && contentTypes[lowerCaseDay]) {
				contentTypes[lowerCaseDay].forEach(contentTypeObj => {
					for (const timing in contentTypeObj) {
						if (contentTypeObj.hasOwnProperty(timing)) {
							const ctype = contentTypeObj[timing];
							const newRecomendation = new PostRecommendationModel();
							newRecomendation.type = RecommendationType.ContentType;
							newRecomendation.contentType = ctype;
							newRecomendation.optLength = optLength;
							newRecomendation.keywords = keywords;
							newRecomendation.topics = topics;
							newRecomendation.categories = categories;
							newRecomendation.emotions = emotions;
							newRecomendation.toBePostedAtUTCHour = parseInt(timing, 10);
							switch (newRecomendation.contentType) {
								case PostContentTypeEnum.Photo:
									newRecomendation.headline = 'Schedule a new image post to improve group activity.';
									newRecomendation.description = this.generateDescription(PostContentTypeEnum.Photo);
									newRecomendation.iconUrl = environment.baseUrl + 'assets/images/icon_image.svg';
									break;
								case PostContentTypeEnum.Video:
									newRecomendation.headline = 'Schedule a new video post to improve group activity.';
									newRecomendation.description = this.generateDescription(PostContentTypeEnum.Video);
									newRecomendation.iconUrl = environment.baseUrl + 'assets/images/icon_video.svg';
									break;

								default:
									newRecomendation.headline = 'Schedule a new text post to improve group activity.';
									newRecomendation.description = this.generateDescription(PostContentTypeEnum.Text);
									newRecomendation.iconUrl = environment.baseUrl + 'assets/images/icon_post.svg';
									break;
							}
							recommendationsMap[day].push(newRecomendation);
						}
					}
				});
			}
		});

		this.calenderDates.forEach(calenderDate => {
			const date = calenderDate[3];
			const day = date.format('dddd');
			if (recommendationsMap[day]) {
				recommendationsMap[day].forEach(recom => {
					const newRecomendation = new PostRecommendationModel();
					newRecomendation.type = recom.type;
					newRecomendation.contentType = recom.contentType;
					newRecomendation.optLength = recom.optLength;
					newRecomendation.keywords = recom.keywords;
					newRecomendation.topics = recom.topics;
					newRecomendation.categories = recom.categories;
					newRecomendation.emotions = recom.emotions;
					newRecomendation.headline = recom.headline;
					newRecomendation.description = recom.description;
					newRecomendation.iconUrl = recom.iconUrl;
					newRecomendation.toBePostedAtUTCHour = recom.toBePostedAtUTCHour;
					const time = new DateTime(`${date.format('ddd MMM DD YYYY')} ${recom.toBePostedAtUTCHour}:00 GMT+0000`);

					if (new DateTime().utc().isAfter(time.dayJsObj)) {
						return;
					}

					newRecomendation.toBePostedAtUTCTicks = time.unix();
					newRecomendation.toBePostedAtInLocalTime = time.local().format('hh:mm A');
					const dateToMatch = time.format('MMM D');

					this.recommendationIdHashMap[newRecomendation.id] = newRecomendation;

					if (this.recommendations[dateToMatch]) {
						const len = this.recommendations[dateToMatch].length;
						for (let index = 0; index < len; index++) {
							const reco = this.recommendations[dateToMatch][index];
							if (reco.toBePostedAtUTCTicks > newRecomendation.toBePostedAtUTCTicks) {
								this.recommendations[dateToMatch].splice(index, 0, newRecomendation);
								break;
							} else if (index + 1 === len) {
								this.recommendations[dateToMatch].push(newRecomendation);
							}
						}
					} else {
						this.recommendations[dateToMatch] = [newRecomendation];
					}
				});
			}
		});
	}

	private generateDescription(contentType: PostContentTypeEnum) {
		const randomTextDesc = [
			'Publish a new text post related to hot topics being discussed in your group and drive higher group activity.',
			"Publish a new post in your group's top 5 category. Category specific posts helps in driving engagement.",
			'Publish a new text post related to seasonal issues. Relevance of post to seasonal issues help in driving higher engagement.',
			'Asking a question that other group members also have can drive a lot of members to participate.',
			'Providing unique and original content for your group members always help in driving engagement. Invest in original content.',
			'Keeping your post short and to the point is always helpful. Go ahead count your words :)',
			'Using emotion generating keywords helps in driving higher engagement with the audience. '
		];
		const randomPhotoDesc = [
			'While posting a photo post keep in mind that using pictures with real people helps in connecting with audience.',
			"Pictures with emotions visible on people's faces help in driving higher activity.",
			'Publish a new photo related to hot topics being discussed in your group and drive higher group activity.',
			"Publish a new photo/album in your group's top 5 category. Category specific photos helps in driving engagement.",
			'Publish a new photo/album related to seasonal issues. Relevance of photos to seasonal issues help in driving higher engagement.',
			'Is your photo asking a question that other group members also have? Such photos can drive a lot of members to participate.',
			'Is your photo unique and original? Investing in original photos for your group members always help in driving engagement.',
			'"A picture is worth a thousand words." Post pictures of noble actions you or your community members have done.'
		];
		const randomVideoDesc = [
			'Videos with purpose or social causes help in uniting your community and driving massive engagement.',
			'Videos should be recorded for mobile devices, they tend to perform better and drive high activity.',
			"Ask your group members to share the video. That's how movements are built.",
			'Useful content for your community in a video post helps in driving engagement. Go ahead post a useful video!',
			'Does your video tell a story? A good story is way better than high production value.',
			'Keeping a good pace in providing information or storytelling is important. Post a video that keeps up the pace with your community.'
		];

		const arrayToChooseFrom =
			contentType === PostContentTypeEnum.Text
				? randomTextDesc
				: contentType === PostContentTypeEnum.Photo
				? randomPhotoDesc
				: randomVideoDesc;

		const min = 1;
		const max = arrayToChooseFrom.length;
		const index = Math.floor(Math.random() * (+max - +min)) + +min;
		return arrayToChooseFrom[index - 1];
	}
}
